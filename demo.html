<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background-color: #faf7fc; 
        }
        #cov {
            height: 100vh;
            width: 100vw;
        }
    </style>
</head>
<body>
    <canvas id="cov"></canvas>
    <script>'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (global) {
    var cacheArr = [];

    var concatArr = function concatArr(targetArr) {
        var arr, i;
        for (i = 1; i < arguments.length; i++) {
            arr = arguments[i];
            Array.prototype.push.apply(targetArr, arr);
        }
    };

    var spliceArr = function spliceArr(arr, index, num) {
        var i, len;
        for (i = index + num, len = arr.length; i < len; i++) {
            arr[i - num] = arr[i];
        }
        arr.length = len - num;
    };

    var Qtree = function () {
        function Qtree(bounds) {
            var level = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

            _classCallCheck(this, Qtree);

            this.objects = [];
            this.nodes = [];
            this.level = level;
            this.bounds = bounds;
            this.MAX_OBJECTS = 10;
            this.MAX_LEVELS = 5;
        }

        _createClass(Qtree, [{
            key: 'clear',
            value: function clear() {
                this.objects.length = 0;
                while (this.nodes.length) {
                    var subnode = this.nodes.shift();
                    subnode.clear();
                }
            }
        }, {
            key: 'split',
            value: function split() {
                var x = this.bounds.x;
                var y = this.bounds.y;
                var sWidth = this.bounds.sWidth;
                var sHeight = this.bounds.sHeight;

                this.nodes.push(new Qtree(new Rect(this.bounds.cX, y, sWidth, sHeight), this.level + 1), new Qtree(new Rect(x, y, sWidth, sHeight), this.level + 1), new Qtree(new Rect(x, this.bounds.cY, sWidth, sHeight), this.level + 1), new Qtree(new Rect(this.bounds.cX, this.bounds.cY, sWidth, sHeight), this.level + 1));
            }
        }, {
            key: 'getIndex',
            value: function getIndex(rect, checkIsInner) {
                var onTop = rect.y + rect.h <= this.bounds.cY;
                var onBottom = rect.y >= this.bounds.cY;
                var onLeft = rect.x + rect.w <= this.bounds.cX;
                var onRight = rect.x >= this.bounds.cX;

                if (checkIsInner && (Math.abs(rect.cX - this.bounds.cX) + rect.sWidth > this.bounds.sWidth || Math.abs(rect.cY - this.bounds.cY) + rect.sHeight > this.bounds.sHeight)) {

                    return -1;
                }

                if (onTop) {
                    if (onRight) {
                        return 0;
                    } else if (onLeft) {
                        return 1;
                    }
                } else if (onBottom) {
                    if (onLeft) {
                        return 2;
                    } else if (onRight) {
                        return 3;
                    }
                }

                return -1;
            }
        }, {
            key: 'insert',
            value: function insert(item) {
                if (this.nodes.length) {
                    var index = this.getIndex(item);
                    if (index !== -1) {
                        this.nodes[index].insert(item);
                        return;
                    }
                }
                this.objects.push(item);

                if (!this.nodes.length && this.objects.length > this.MAX_OBJECTS && this.level < this.MAX_LEVELS) {

                    this.split();

                    for (var _i = this.objects.length - 1; _i >= 0; _i--) {
                        var _index = this.getIndex(this.objects[_i]);
                        if (_index !== -1) {
                            this.nodes[_index].insert(this.objects.splice(_i, 1)[0]);
                        }
                    }
                }
            }
        }, {
            key: 'refresh',
            value: function refresh(scope) {
                scope = scope || this;

                for (var _i2 = this.objects.length - 1; _i2 >= 0; _i2--) {
                    var index = this.getIndex(this.objects[_i2], true);
                    if (index === -1) {
                        if (this !== scope) {
                            scope.insert(this.objects.splice(_i2, 1)[0]);
                        }
                    } else if (this.nodes.length) {
                        this.nodes[index].insert(this.objects.splice(_i2, 1)[0]);
                    }
                }

                for (var _i3 = 0, _len = this.nodes.length; _i3 < _len; _i3++) {
                    this.nodes[_i3].refresh(scope);
                }
            }
        }, {
            key: 'retrieve',
            value: function retrieve(rect) {
                var result = cacheArr;

                if (this.level === 0) result.length = 0;

                concatArr(result, this.objects);

                if (this.nodes.length) {
                    var index = this.getIndex(rect);
                    if (index !== -1) {
                        this.nodes[index].retrieve(rect);
                    } else {
                        var arr = rect.carve(this.bounds.cX, this.bounds.cY);
                        for (var _i4 = arr.length - 1; _i4 >= 0; _i4--) {
                            index = this.getIndex(arr[_i4]);
                            this.nodes[index].retrieve(rect);
                        }
                    }
                }

                return result;
            }
        }]);

        return Qtree;
    }();

    var Rect = function () {
        function Rect(x, y, width, height) {
            var speedArr = arguments.length <= 4 || arguments[4] === undefined ? [20, 20] : arguments[4];

            _classCallCheck(this, Rect);

            this.speedArr = speedArr;
            this.nextSpeedArr = this.speedArr.slice();
            this.resize(width, height);
            this.moveTo(x, y);
        }

        _createClass(Rect, [{
            key: 'moveTo',
            value: function moveTo(x, y) {
                this.x = x;
                this.y = y;
                this.cX = x + this.sWidth;
                this.cY = y + this.sHeight;
            }
        }, {
            key: 'resize',
            value: function resize(width, height) {
                this.w = width;
                this.h = height;
                this.sWidth = width / 2;
                this.sHeight = height / 2;
            }
        }, {
            key: 'draw',
            value: function draw(cxt) {
                cxt.save();
                cxt.beginPath();
                cxt.rect(this.x, this.y, this.w, this.h);
                cxt.closePath();
                cxt.restore();
            }
        }, {
            key: 'run',
            value: function run() {
                this.speedArr[0] = this.nextSpeedArr[0];
                this.speedArr[1] = this.nextSpeedArr[1];

                this.moveTo(this.x + this.speedArr[0] * 0.016, this.y + this.speedArr[1] * 0.016);
            }
        }, {
            key: 'copy',
            value: function copy(rect) {
                this.resize(rect.w, rect.h);
                this.moveTo(rect.x, rect.y);
                this.nextSpeedArr[0] = rect.speedArr[0];
                this.nextSpeedArr[1] = rect.speedArr[1];
            }
        }, {
            key: 'init',
            value: function init(x, y, w, h, speedArr) {
                this.resize(w, h);
                this.moveTo(x, y);
            }
        }, {
            key: 'collide',
            value: function collide(rect, isInner) {
                var tRect1 = tempRectArr[0],
                    tRect2 = tempRectArr[1],
                    thisRect = void 0,
                    sWidthSum = void 0,
                    sHeightSum = void 0,
                    dWidth = void 0,
                    dHeight = void 0,
                    onHorizontal = void 0,
                    onVertical = void 0,
                    focusPoint = void 0;

                if (!isInner) {

                    tRect1.copy(this);
                    tRect2.copy(rect);

                    sWidthSum = tRect1.sWidth + tRect2.sWidth;
                    sHeightSum = tRect1.sHeight + tRect2.sHeight;
                    dWidth = sWidthSum - Math.abs(tRect1.cX - tRect2.cX);
                    dHeight = sHeightSum - Math.abs(tRect1.cY - tRect2.cY);

                    while (dWidth > 0 && dHeight > 0) {
                        tRect1.run(-16);
                        tRect2.run(-16);
                        dWidth = sWidthSum - Math.abs(tRect1.cX - tRect2.cX);
                        dHeight = sHeightSum - Math.abs(tRect1.cY - tRect2.cY);
                    }

                    onHorizontal = dWidth <= 0;
                    onVertical = dHeight <= 0;

                    // 改变方向
                    if (onHorizontal) {
                        focusPoint = this.cX > rect.cX ? 1 : -1;
                        this.nextSpeedArr[0] = focusPoint * (Math.abs(this.nextSpeedArr[0]) + Math.abs(rect.speedArr[0])) / 2;
                    }

                    if (onVertical) {
                        focusPoint = tRect1.cY > tRect2.cY ? 1 : -1;
                        this.nextSpeedArr[1] = focusPoint * (Math.abs(this.nextSpeedArr[1]) + Math.abs(rect.speedArr[1])) / 2;
                    }
                } else {
                    if (Math.abs(this.cX - rect.cX) + this.sWidth > rect.sWidth) {
                        this.nextSpeedArr[0] = -(this.nextSpeedArr[0] || this.speedArr[0]);
                        this.moveTo(this.cX > rect.cX ? rect.x + rect.w - this.w : rect.x, this.y);
                    }
                    if (Math.abs(this.cY - rect.cY) + this.sHeight > rect.sHeight) {
                        this.nextSpeedArr[1] = -(this.nextSpeedArr[1] || this.speedArr[1]);
                        this.moveTo(this.x, this.cY > rect.cY ? rect.y + rect.h - this.h : rect.y);
                    }
                }
            }
        }, {
            key: 'carve',
            value: function carve(cX, cY) {
                var result = [],
                    temp = [],
                    dX = cX - this.x,
                    dY = cY - this.y,
                    carveX = dX > 0 && dX < this.w,
                    carveY = dY > 0 && dY < this.h;

                if (carveX && carveY) {
                    temp = this.carve(cX, this.y);
                    while (temp.length) {
                        result = result.concat(temp.shift().carve(this.x, cY));
                    }
                } else if (carveX) {
                    result.push(new Rect(this.x, this.y, dX, this.h), new Rect(cX, this.y, this.w - dX, this.h));
                } else if (carveY) {
                    result.push(new Rect(this.x, this.y, this.w, dY), new Rect(this.x, cY, this.w, this.h - dY));
                }

                return result;
            }
        }, {
            key: 'isApproach',
            value: function isApproach(rect1, rect2) {
                var tRect1 = tempRectArr[0];
                var tRect2 = tempRectArr[1];

                tRect1.copy(rect1);
                tRect2.copy(rect2);

                tRect1.run();
                tRect2.run();

                return +(Math.pow(rect1.cX - rect2.cX, 2) - Math.pow(tRect1.cX - tRect2.cX, 2) + Math.pow(rect1.cY - rect2.cY, 2) - Math.pow(tRect1.cY - tRect2.cY, 2)).toFixed(6) > 0 ? true : false;
            }
        }, {
            key: 'isCollide',
            value: function isCollide(rect1, rect2) {
                if (Math.abs(rect1.cX - rect2.cX) < rect1.sWidth + rect2.sWidth && Math.abs(rect1.cY - rect2.cY) < rect1.sHeight + rect2.sHeight && this.isApproach(rect1, rect2)) {

                    rect1.collide(rect2);
                    rect2.collide(rect1);
                }
            }
        }]);

        return Rect;
    }();

    var Dot = function (_Rect) {
        _inherits(Dot, _Rect);

        function Dot(x, y, width, height) {
            var speedArr = arguments.length <= 4 || arguments[4] === undefined ? [0, 0] : arguments[4];

            _classCallCheck(this, Dot);

            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Dot).call(this, x, y, width, height, speedArr));

            _this.x = x;
            _this.y = y;
            _this.radius = width * .5;
            _this.width = width;
            _this.height = height;
            _this.speedArr = speedArr;
            _this.nextSpeedArr = speedArr.slice();
            _this.linkCount = 0;
            _this.updateColor();
            return _this;
        }

        _createClass(Dot, [{
            key: 'updateColor',
            value: function updateColor(screenWidth, screenHeight) {
                this.color = 'rgb(' + Math.floor(255 * (1 - this.x / screenWidth)) + ', ' + Math.floor(255 * (1 - this.y / screenHeight)) + ',' + Math.floor(255 * (this.speedArr[0] / 100)) + ')';
            }
        }, {
            key: 'draw',
            value: function draw(cxt) {
                cxt.fillStyle = this.color;
                cxt.save();
                cxt.beginPath();
                cxt.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
                cxt.fill();
                cxt.restore();
            }
        }, {
            key: 'willOut',
            value: function willOut(width, height) {
                if (this.x + this.speedArr[0] > width || this.x + this.speedArr[0] < 0) {
                    this.speedArr[0] = -this.speedArr[0];
                }
                if (this.y + this.speedArr[1] > height || this.y + this.speedArr[1] < 1) {
                    this.speedArr[1] = -this.speedArr[1];
                }
            }
        }, {
            key: 'linkWith',
            value: function linkWith(item, cxt) {
                cxt.strokeStyle = this.color;
                cxt.lineWidth = .4;
                cxt.beginPath();
                cxt.moveTo(this.x, this.y);
                cxt.lineTo(item.x, item.y);
                cxt.stroke();
                cxt.closePath();
                cxt.save();
                item.linkCount++;
            }
        }, {
            key: 'canLink',
            value: function canLink(dots, cxt) {
                var _this2 = this;

                dots.forEach(function (dot) {
                    if (dot.linkCount < 6) {
                        _this2.linkWith(dot, cxt);
                    }
                });
            }
        }]);

        return Dot;
    }(Rect);

    global.Dot = Dot;
    global.Rect = Rect;
    global.Qtree = Qtree;

    var tempRectArr = [];
    tempRectArr.push(new Rect(0, 0, 0, 0), new Rect(0, 0, 0, 0));
})(window);

(function (global, doc) {
    var canvas = document.getElementById('cov');
    var cxt = canvas.getContext('2d');
    var Dot = global.Dot;
    var Qtree = global.Qtree;
    var Rect = global.Rect;
    var screenWidth = window.innerWidth;
    var screenHeight = window.innerHeight - 10;

    var dotArr = [];

    canvas.height = screenHeight;
    canvas.width = screenWidth;
    canvas.setAttribute('style', 'height: ' + screenHeight + 'px; width: ' + screenWidth + 'px');

    for (var i = 0; i < 64; i++) {
        dotArr.push(new Dot(Math.floor(Math.random() * (screenWidth - 20)), Math.floor(Math.random() * (screenHeight - 20)), Math.random() * 20 + 5, Math.random() * 20 + 5, [Math.random() * 10 + 20 * (Math.random() * 10 > 5 ? -1 : 1), Math.random() * 10 + 20 * (Math.random() * 10 > 5 ? -1 : 1)]));
    }

    var tree = new Qtree(new Rect(0, 0, screenWidth, screenHeight));

    for (var _i5 = 0, l = dotArr.length; _i5 < l; _i5++) {
        tree.insert(dotArr[_i5]);
    }

    var draw = function draw() {
        var tempRect = [];

        cxt.clearRect(0, 0, screenWidth, screenHeight);

        tree.refresh();

        for (var i = 0, len = dotArr.length; i < len; i++) {

            tempRect = tree.retrieve(dotArr[i]);
            dotArr[i].canLink(tempRect, cxt);

            for (var j = 0; j < tempRect.length; j++) {
                dotArr[i].isCollide(dotArr[i], tempRect[j]);
            }

            dotArr[i].collide(new Rect(0, 0, screenWidth, screenHeight), true);
        }

        for (i = 0, len = dotArr.length; i < len; i++) {
            dotArr[i].run();
            dotArr[i].updateColor(screenWidth, screenHeight);
            dotArr[i].draw(cxt);
            dotArr[i].linkCount = 0;
        }

        requestAnimationFrame(draw);
    };
    requestAnimationFrame(draw);
})(window, window.document);
    </script>
</body>
</html>